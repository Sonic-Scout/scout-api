use crate::defi::models::*;
use crate::models::AppState;
use crate::profiles::{ProfileDatabase};
use crate::wallets::{WalletDatabase};
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use ethers::prelude::*;

pub async fn get_quote(
    State(state): State<AppState>,
    Json(req): Json<GetQuoteRequest>,
) -> Result<Json<QuoteResponse>, (StatusCode, String)> {
    let params = QuoteParams {
        from_token_address: req.from_token,
        to_token_address: req.to_token,
        amount: req.amount,
        slippage: req.slippage,
        from_address: req.from_address,
        to_address: req.to_address,
        gasless: req.gasless,
        affiliate_address: req.affiliate_address,
        affiliate_fee: req.affiliate_fee,
    };

    let response = state.magpie.get_quote(&params).await.map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to get quote: {}", e),
        )
    })?;

    Ok(Json(response))
}

pub async fn execute_swap(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
    Json(req): Json<ExecuteSwapRequest>,
) -> Result<Json<SwapResponse>, (StatusCode, String)> {
    let _quote_details = state
        .magpie
        .get_transaction(&req.quote_id)
        .await
        .map_err(|e| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Failed to get transaction data: {}", e),
            )
        })?;

    let profile_db = ProfileDatabase::new().unwrap();
    let wallet_db = WalletDatabase::new().unwrap();
    let profile = profile_db.get(&user_id).unwrap();
    let wallet = wallet_db.get(&profile.unwrap().wallet).unwrap();

    // For gasless swap, need to generate signatures
    if let Some(user_wallet) = wallet {
        // Create a wallet from the private key
        let _wallet = user_wallet.private.parse::<LocalWallet>().map_err(|e| {
            (
                StatusCode::BAD_REQUEST,
                format!("Invalid wallet key: {}", e),
            )
        })?;

        // This would require accessing the EIP-712 message from the quote response
        // Simplified for example - in a real implementation, you would properly construct and sign the message
        let swap_signature = "0x...".to_string(); // This would be generated by proper EIP-712 signing

        let params = GaslessSwapParams {
            network_name: req.network_name,
            quote_id: req.quote_id,
            swap_signature: swap_signature,
            permit_signature: None,
            permit_deadline: req.permit_deadline.map(|d| d.to_string()),
        };

        let response = state
            .magpie
            .execute_gasless_swap(&params)
            .await
            .map_err(|e| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    format!("Failed to execute gasless swap: {}", e),
                )
            })?;

        Ok(Json(response))
    } else {
        // For self-execution, just return the transaction data
        Err((
            StatusCode::NOT_IMPLEMENTED,
            "Self-execution not implemented in this example. Transaction data retrieved, but user must handle broadcasting.".to_string(),
        ))
    }
}

pub async fn get_swap_status(
    State(state): State<AppState>,
    Query(req): Query<SwapStatusRequest>,
) -> Result<Json<SwapStatusResponse>, (StatusCode, String)> {
    let response = state
        .magpie
        .get_swap_status(&req.wallet_address)
        .await
        .map_err(|e| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Failed to get swap status: {}", e),
            )
        })?;

    Ok(Json(response))
}

pub async fn get_swap_details(
    State(state): State<AppState>,
    Query(req): Query<SwapDetailsRequest>,
) -> Result<Json<SwapDetailsResponse>, (StatusCode, String)> {
    let response = state
        .magpie
        .get_swap_details(&req.swap_id)
        .await
        .map_err(|e| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Failed to get swap details: {}", e),
            )
        })?;

    Ok(Json(response))
}

pub async fn get_distributions(
    State(state): State<AppState>,
    Query(req): Query<GetDistributionsRequest>,
) -> Result<Json<DistributionsResponse>, (StatusCode, String)> {
    let response = state
        .magpie
        .get_distributions(&req.quote_id)
        .await
        .map_err(|e| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Failed to get distributions: {}", e),
            )
        })?;

    Ok(Json(response))
}
